#!/usr/bin/perl -w

#  this is an example of a FAIR Linked Data Platform server

use strict;

use RD_Connect_Common;
use JSON;
use URI::Escape;


my %Configuration = readConfiguration();  # read the configuration file (currently no sanity checking)

unless ($ENV{REQUEST_METHOD}){  # if running from command line
        $ENV{REQUEST_METHOD} = "GET";
        $ENV{'REQUEST_URI'} = "/this/thing";
        $ENV{'SERVER_NAME'} = "antirrhinum.net";
	$ENV{'PATH_INFO'} = "/479-467-29X";
}


my $URL = "http://" . $ENV{'SERVER_NAME'} . $ENV{'REQUEST_URI'} ; 

# THIS ROUTINE WILL BE SHARED BY ALL SERVERS
if ($ENV{REQUEST_METHOD} eq "HEAD") {
    manageHEAD($Configuration{ETAG});
    exit;
} elsif ($ENV{REQUEST_METHOD} eq "OPTIONS"){
    manageHEAD($Configuration{ETAG});
    exit;
}  elsif ($ENV{REQUEST_METHOD} eq "GET") {
	if ($ENV{'PATH_INFO'}) {  # this will never happen with the minimal server
		printResourceHeader($Configuration{ETAG});
		manageResourceGET($URL);
	} else {
		printContainerHeader($Configuration{ETAG});
		manageContainerGET($URL);
	}
} else {
    print "Status: 405 Method Not Allowed\n"; 
    print "Content-type: text/plain\n\nYou can only request HEAD, OPTIONS or GET from this LD Platform Server\n\n";
    exit 0;
}



sub manageContainerGET {
    my $URL = shift;
    my $store = RDF::Trine::Store::Memory->new();
    my $model = RDF::Trine::Model->new($store);
    my $ns = RDF::NS->new('20131205');   # check at runtime
    die "can't set namespace $!\n" unless ($ns->SET(ldp => 'http://www.w3.org/ns/ldp#'));
    
    my $statement = statement($URL, $ns->rdf("type"), $ns->ldp("BasicContainer")); 
    $model->add_statement($statement); 
    $statement = statement($URL, $ns->dc("title"), $Configuration{'Title'}); 
    $model->add_statement($statement); 
    
    callMetadataAccessor($URL, $model);
    
    serializeThis($model);

}


sub callMetadataAccessor {
	my ($subject, $model) = @_;
	require $Configuration{'DataSourceConnectorFile'};
	my $package = $Configuration{'DataSourceConnectorPackage'};
	my $method = $Configuration{'DataSourceMetadataMethod'};
	no strict 'refs';
	my $result = $package->$method;
	$result = decode_json($result);
	use strict 'refs';

	foreach my $CDE(@CDE){  # @CDE exported from RD_Connect_Common.pm
		next unless $result->{$CDE};
		my ($namespace, $term) = split /:/, $CDE;
		
		if (ref($result->{$CDE}) =~ /ARRAY/) {
			foreach (@{$result->{$CDE}}){
				my $statement = statement($subject, $NS->$namespace($term), $_); 
				$model->add_statement($statement);
			}
			next;
		}
		
		my $statement = statement($subject,$NS->$namespace($term), $result->{$CDE}); 
		$model->add_statement($statement);
	}
	
	foreach my $meta_records (@{$result->{'database:records'}}) {
	    my $statement = statement($subject, $NS->ldp("contains"), $URL."/".uri_escape($meta_records)); 
	    $model->add_statement($statement);         

		
	}
}

sub manageResourceGET {
    my $URL = shift;
    my $record = $ENV{'PATH_INFO'};
    $record =~ s/^\///;
    my $store = RDF::Trine::Store::Memory->new();
    my $model = RDF::Trine::Model->new($store);
    
    my $statement = statement($URL, $NS->rdf("type"), $NS->edam("data_0006")); 
    $model->add_statement($statement); 
    $statement = statement($URL, $NS->rdf("type"), $	NS->sio("SIO_000088")); 
    $model->add_statement($statement); 
    $statement = statement($URL, $NS->dcat("distribution"), "http://biordf.org/cgi-bin/RD_Connect/patient_record/$record"); 
    $model->add_statement($statement); 
    
	callDataAccessor($URL, $model, $record);

	serializeThis($model);

}

    

sub callDataAccessor {
	my ($subject, $model, $record) = @_;
	require $Configuration{'DataSourceConnectorFile'};
	my $package = $Configuration{'DataSourceConnectorPackage'};
	my $method = $Configuration{'DataSourceDataMethod'};
	no strict 'refs';
	my $result = $package->$method($record);
	$result = decode_json($result);
	use strict 'refs';
	
    foreach my $key(keys %$result){
	my ($ns,$pred) = split /:/, $key;
	my $value = $result->{$key};
	my $statement = statement("$URL",  $NS->$ns($pred), $value); 
	$model->add_statement($statement); 

    }

}
