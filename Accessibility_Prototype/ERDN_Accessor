#!/usr/bin/perl -w

package ERDN_Accessor;  # this should be the same as your filename!

use strict;
use warnings;
use JSON;


#-----------------------------------------------------------------
# Configuration and Daemon
#-----------------------------------------------------------------

use base 'FAIR::Accessor';

my $config = {
    title => 'ERDN Data Accessor',
    serviceTextualDescription => 'Server for some ERDN Data',
    textualAccessibilityInfo => "This information requries no authentication",  # this could also be a $URI describing the accessibiltiy
    mechanizedAccessibilityInfo => "",  # this must be a URI to an RDF document
    textualLicenseInfo => "CC-BY",  # this could also be a URI to the license info
    mechanizedLicenseInfo =>  "", # this must be a URI to an RDF document
    baseURI => "", # I don't know what this is used for yet, but I have a feeling I will need it!
    ETAG_Base => "ERDN_Accessor_For_RegInfo", # this is a unique identificaiton string for the service (required by the LDP specification)
    localNamespaces => {erdn => 'http://erdn.org/some/items/',
                        erdnpred => 'http://erdn.org/some/predicates/'},  # add a few new namespaces to the list of known namespaces....
    localMetadataElements => [qw(erdnpred:fromHospital erdnpred:lastevaluatedDate) ],  # things that we use in addition to common metadata elements

};

my $service = ERDN_Accessor->new(%$config);

# start daemon
$service->handle_requests;




#-----------------------------------------------------------------
# Accessor Implementation
#-----------------------------------------------------------------



=head2 get_all_meta_URIs

 Function: returns the first-stage LD Platform list of contained URIs and the dataset metadata.
 Args    : $starting_at_record : this will be passed-in to tell you what record to start with (for paginated responses)
 $path : the webserver's PATH_INFO environment value (used to modify the behaviour of REST services)
 Returns : JSON encoded listref of 'meta URIs' representing individual records
 Note    :  meta URIs are generally URIs that point back to this same server; calling GET on a meta URI will
            return an RDF description of the set of DCAT distributions for that record.\
            this can be handled by the

=cut

sub get_all_meta_URIs {

    my ($starting_at_record, $path_info) = @_;
    $path_info ||="";
    
    my %result =  (  # NOTE THAT ALL OF THESE ARE OPTIONAL!  (and there are more fields.... see DCAT...)
                    'dc:title' => "EHDN Accessor Server",
                   'dcat:description' => "the prototype Accessor server for EHDN",
                    'dcat:identifier' => "handle:12345566798",
                    'dcat:keyword' => ["medical records", "rare diseases", "EHDN", "Linked Data Platform", 'HTT', 'huntington disease', 'huntingtin'],
                    'dcat:landingPage' => 'http://www.euro-hd.net/html/network',
                    'dcat:language' => 'en',
                    'dcat:publisher' => 'http://www.euro-hd.net',
                    'dcat:temporal' => 'http://reference.data.gov.uk/id/quarter/2006-Q1',  # look at this!!  It doesn't have to be this complex, but it can be!
                    'dcat:theme'  => 'http://example.org/skos/definition/of/theme',  # this is the URI to a SKOS Concept Scheme
                    'daml:has-Technical-Lead' => "Summer Student Joe",
                    'daml:has-Administrative-Contact' => "John Doe",
                    'daml:has-Program-Manager' => "Jane Doe",
                    'daml:has-Principle-Investigator' => "Big Doctor",
                  );
    my $BASE_URL = "http://" . $ENV{'SERVER_NAME'} . $ENV{'REQUEST_URI'} . $path_info;
    my @known_records = ($BASE_URL . "/479-467-29X",
                         $BASE_URL . "/768-599-467",
                         # ...  you need to generate this list of record URIs here... somehow
                        );
    
    $result{'void:entities'} = scalar(@known_records);  #  THE TOTAL *NUMBER* OF RECORDS THAT CAN BE SERVED
    $result{'ldp:contains'} = \@known_records; # the listref of record ids
    
    return encode_json(\%result);

}


=head2 get_distribution_URIs

 Function: returns the second-stage LD Platform metadata describing the DCAT distributions, formats, and URLs
           for a particular record
 Args    : $ID : the desired ID number, as determined by the Accessor.pm module
           $PATH_INFO : the webserver's PATH_INFO environment value (in case the $ID best-guess is wrong... then you're on your own!)
 Returns : JSON encoded hashref of 'meta URIs' representing individual DCAT distributions and their formats (format is key)
            The format for this response is:
            
            {"metadata":
                {"rdf:type": ["edam:data_0006","sio:SIO_000088"]
                },
            "distributions":
                {"application/rdf+xml":"http://myserver.org/ThisScript/record/479-467-29X.rdf",
                 "text/html":"http://myserver.org/ThisScript/record/479-467-29X.html"
                }
            }

=cut


sub get_distribution_URIs {
    my ($self, $ID, $PATH_INFO) = @_;

    my %response;

    my %formats;
    my %metadata;
    
    $formats{'text/html'} = 'http://myserver.org/ThisScript/record/479-467-29X.html';
    $formats{'application/rdf+xml'} = 'http://myserver.org/ThisScript/record/479-467-29X.rdf';

    # set the ontological type for the record  (optional)
    $metadata{'rdf:type'} = ['edam:data_0006', 'sio:SIO_000088'];
    
    # and whatever other metadata you wish (also optional)
    extractDataFromSpreadsheet(\%metadata, $ID);    

    $response{distributions} = \%formats;
    $response{metadata} = \%metadata if (keys %metadata);  # only set it if you can provided something

    my $response  = encode_json(\%response);
    
    return $response;

}


# this is a service-specific piece of code, completely optional!
sub extractDataFromSpreadsheet{
    my ($metadata, $ID) = @_;
    
    use Spreadsheet::XLSX::Reader::LibXML;
    my $db_file = "registry3-enrolment.xlsx.xlsx";
    
    my $excel = Spreadsheet::XLSX::Reader::LibXML->new();
    my $workbook = $excel->parse($db_file);
    my ($sheet) = $workbook->worksheets;
    my ($first, $last) = $sheet->row_range;
    foreach my $row ($first .. $last) {
    
        next unless ($sheet->get_cell($row, 0)->value eq $ID);
        
        my $cell = $sheet->get_cell($row, 5);
          $metadata->{'dcat:updateDate'} = $cell->value;
        
        $cell = $sheet->get_cell($row, 1);
          $metadata->{'dcat:releaseDate'} = $cell->value;
          
        $cell = $sheet->get_cell($row, 3);
          $metadata->{'erdnpred:enrollmentState'} = $cell->value;
        
        last;
    }

}
